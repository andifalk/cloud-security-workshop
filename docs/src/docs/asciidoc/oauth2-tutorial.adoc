
= Exercise for OAuth2 security
Andreas Falk <andreas.falk@novatec-gmbh.de>
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectlinks:
:numbered: ''
:docinfo:

== System Requirements

To successfully complete this exercise you need the following:

* JDK 7 or 8
* A Java IDE like Eclipse, IntelliJ or Visual Studio Code

WARNING: JDK 9, 10, 11 cannot be used as we are using Spring Framework 4.x and
Spring Boot 1.5. These are not compatible with JDK 9 and newer!

== What we will build

.We will extend the existing two microservices to use single sign authentication based on OAuth2.

* OAuth2 Authorization Server: This is the new microservice for single sign on which holds all users with their credentials
* OAuth2 Resource Server (Product Backend): The microservice providing product data maps to a resource server
* OAuth2 Client (UI Microservice): The thymeleaf UI microservice consuming the products maps to an OAuth2 client

image::images/oauth2services.png[scaledwidth="75%",alt="OAuth2 roles"]

These microservices have to be configured to be reachable via the following URL addresses (Port 8080 is the default port in spring boot).

.Microservice URL Adresses
|===
|Microservice |URL
|Authorization Server
|http://localhost:9999/users
|Client (UI)
|http://localhost:8081
|Resource Server (Products)
|http://localhost:8080
|===

TIP: You can find more information on building OAuth2 secured microservices with spring in
https://docs.spring.io/spring-boot/docs/1.5.x/reference/htmlsingle/#boot-features-security-oauth2[Spring Boot Reference Documentation]
and in https://projects.spring.io/spring-security-oauth/docs/oauth2.html[Spring Security OAuth2 Developers Guide]

== Step 1

In step 1 we will build a basic OAuth2 secured microservices infrastructure using simple user credentials provided
via properties in _application.properties_.

To start implementing make sure you checked out the initial code in sub folder _'initial'_ from

https://github.com/andifalk/cloud-security-workshop

[[authorization-server]]
=== Authorization Server

TIP: You may look into the spring boot reference documentation https://docs.spring.io/spring-boot/docs/1.5.x/reference/htmlsingle/#boot-features-security-oauth2-authorization-server[Spring Boot Reference Documentation]
on how to implement an authorization server.

IMPORTANT: To prevent conflicts with different `JSESSION` cookies the authorization server must run
on a separate context path (not in root _'/'_). In our example please use _'/users'_ as context path. In spring boot
this can be achieved by the _server.context_ property

To ensure OAuth2 authorization code grant works correctly with the other components the end points
of the authorization server must be as follows:

.Authorization Server Endpoints
|===
|Endpoint |Description |Caller
|/oauth/authorize
|Authorization endpoint (for login and client authorization)
|Client
|/oauth/token
|Token endpoint (exchanges given authorization code for access token)
|Client
|/oauth/check_token
|Check token endpoint (returns internal contents for access token)
|Resource Server
|===

[[authorization-server-maven-dependencies]]
==== Maven dependencies

include::{snippets}/authserver-mavenpom.adoc[]

==== Java Implementation

include::{snippets}/authserver-java.adoc[]

[[authorization-server-configuration]]
==== Configuration

include::{snippets}/authserver-props.adoc[]

[[resource-server]]
=== Resource Server (Products)

TIP: You may look into the spring boot reference documentation https://docs.spring.io/spring-boot/docs/1.5.x/reference/htmlsingle/#boot-features-security-oauth2-resource-server[Spring Boot Reference Documentation]
on how to implement a resource server.

[[resource-server-maven-dependencies]]
==== Maven dependencies

Add the following required dependencies to the existing maven pom file.

include::{snippets}/resourceserver-mavenpom.adoc[]

==== Java Implementation

The existing products service now should act as an OAuth2 resource server.
Therefore it has to be marked as such.

include::{snippets}/resourceserver-java.adoc[]

[[resource-server-configuration]]
==== Configuration

The following additional properties are required to make the resource server work with our new
authorization server.

include::{snippets}/resourceserver-props.adoc[]

[[client]]
=== OAuth2 Client (Thymeleaf UI)

TIP: You may look into the spring boot reference documentation https://docs.spring.io/spring-boot/docs/1.5.x/reference/htmlsingle/#boot-features-security-oauth2-single-sign-on[Spring Boot Reference Documentation]
on how to implement an OAuth2 single-sign-on client.

[[client-maven-dependencies]]
==== Maven dependencies

Add the following required dependencies to the existing maven pom file.

include::{snippets}/client-mavenpom.adoc[]

[[client-java-implementation]]
==== Java Implementation

The UI client now acts as OAuth2 client and must be marked as such.
Additionally to automatically use the OAuth2 tokens with all calls to REST services
the currently used _RestTemplate_ has to be replaced with new _OAuth2RestTemplate_

NOTE: In more advanced cloud scenarios you may also
use http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#spring-cloud-feign[Feign Client]
instead of _OAuth2RestTemplate_ to call the REST Api. In that case you have to add an interceptor
for OAuth2.

include::{snippets}/client-java.adoc[]

include::{snippets}/client-service-java.adoc[]

[[client-configuration]]
==== Configuration

The following additional properties are required to make the UI client work with our new
authorization server.

include::{snippets}/client-props.adoc[]

== Step 2

.To make the sample application even more secure we will enhance the authorization server to...
- ...enable login using a form login page
- ...use a persistent store for users
- ...encrypt the passwords

If you did not finish step 1 to start implementing step 2 you can use projects in sub folder _'step1'_ of checked out from
as starting point.

https://github.com/andifalk/cloud-security-workshop

=== Provide form based login

A form based login is more user friendly authentication and should always be preferred over
basic authentication popups.
To provide an automatically generated form based login just extend the predefined class _WebSecurityConfigurerAdapter_.

include::{snippets}/authserver-formlogin-java.adoc[]

TIP: You may look into the spring security reference documentation https://docs.spring.io/spring-security/site/docs/4.2.x/reference/htmlsingle/#jc-form[Spring Security Reference Documentation]
on how to configure authentication options like form login.

=== Use persistent store

Until now we have authenticated ourselves using credentials that are defined via application properties
which is ok for demo purposes but definetly not for production use.

.Therefore we introduce a new persistent _User_ entity which has the following attributes:
- firstname
- lastname
- email
- password

NOTE: To actually use the new _User_ entity with spring security this entity class has to implement the predefined
interface _UserDetails_ as well. Please use the attribute _email_ as _username_.

A corresponding repository interface and a data initializer component (just like the one for products)
have to be implemented as well.

Finally spring security must be aware to use the persistent users now instead of the one
defined in the properties. To achieve this you have to implement the interface
_UserDetailsService_ as well to provide an operation loading a user for authentication.

include::{snippets}/authserver-userdetailsservice-java.adoc[]

include::{snippets}/authserver-userdetailsservice-cfg-java.adoc[]

TIP: You may look into the spring security reference documentation https://docs.spring.io/spring-security/site/docs/4.2.x/reference/htmlsingle/#jc-authentication-userdetailsservice[Spring Security Reference Documentation]
on how to add a custom user details service.

=== Encrypt the passwords

In the last step we want to change the storage of cleartext passwords for the users in the database.
If any attacker gets hold of our database then all passwords are leaked.
Therefore a production system must *ALWAYS* store any sensible data like passwords, credit card numbers etc.
encrypted using a proven cryptographic algorithm.

TIP: You may look into the spring security reference documentation https://docs.spring.io/spring-security/site/docs/4.2.x/reference/htmlsingle/#core-services-password-encoding[Spring Security Reference Documentation]
on how to securely encode passwords.

include::{snippets}/password-encoder-java.adoc[]

.Lucklily spring security already provides safe implementations of a _PasswordEncoder_:
- Pbkdf2PasswordEncoder
- BCryptPasswordEncoder
- SCryptPasswordEncoder

To support authentication using encrypted passwords the current web security configuration has to be extended
by the _PasswordEncoder_ to be used.

include::{snippets}/authserver-passwordencoder-cfg-java.adoc[]

NOTE: The passwords have to be stored in encrypted form as well,
so don't forget to inject and use a _PasswordEncoder_ instance in
your user data initializer.

TIP: You may use the h2 console to have a look into the in-memory database to see that the user passwords
are really stored as encrypted values now.
See http://docs.spring.io/spring-boot/docs/1.5.x/reference/htmlsingle/#boot-features-sql-h2-console[Spring Boot Reference Docs] on
how to use and configure this.

